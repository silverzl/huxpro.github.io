---
layout:     post
title:      "指令系统"
subtitle:   "微机系统与接口期末复习"
date:       2019-12-2 10:00:00
author:     "zl"
header-img: "img/post-bg-2019.jpg"
tags:
    - 期末复习系列
---

### 概述

- 指令：
控制计算机完成某种操作的命令
- 指令系统：
处理器所能识别的所有指令的集合
- 指令的兼容性：
同一系列机的指令都是兼容的。

#### 指令格式

指令中应包含：运算数据的来源，运算结果的去向，执行的操作

> 操作数 [操作码] [操作码]

有零，单，双，多操作数。

1. 立即数操作数：本身为参加操作的数字。

> MOV AX, 1234H

2.  参加运算的数存放在指令给出的寄存器中(在三类操作数中所需运行时间最短)

> MOV AX, bx

3. 存储器操作数:参加运算的数存放在存储器的某一个或某两个单元中。(在三类操作数中所需运行时间最长)

>MOV  AX，[1200H]

指令执行速度： 快——慢 寄存器——立即数——存储器 


### 寻址方式

- 操作数可能的来源或存放处：由指令直接给出，寄存器，内存单元
- 寻找操作数所在地址的方法可以有三种大类型：指令直接给出的方式，存放于寄存器中的寻址方式，存放于存储器中的寻址方式

1. 立即数寻址：指令中的源操作数是立即数

![avatar](/img/in-post/2019-12-23-weiji1/1.PNG)

2. 寄存器寻址：参加操作的操作数在CPU的通用寄存器中。

![avatar](/img/in-post/2019-12-23-weiji1/2.PNG)

3. 直接寻址：指令中直接给出操作数的偏移地址

![avatar](/img/in-post/2019-12-23-weiji1/3.PNG)


操作数的段地址默认为数据段，但允许段重设，即由指令定义段。

例：MOV  AX，ES：[1200H]


4. 寄存器间接寻址: 参与操作的操作数存放在内存中，其偏移地址为指令中的寄存器的内容。

![avatar](/img/in-post/2019-12-23-weiji1/4.PNG)

- 由寄存器间接给出操作数的偏移地址；
- 存放偏移地址的寄存器称为间址寄存器，它们是：BX，BP，SI，DI

基址寻址（间址寄存器为基址寄存 器BX，BP）

变址寻址（间址寄存器为变址寄存 器SI，DI）

5. 寄存器相对寻址：操作数的偏移地址为寄存器的内容加上一个位移量

> MOV  AX，[BX+DATA] 

- 操作数的偏移地址为
一个基址寄存器的内容 + 一个变址寄存器的内容；
- 操作数的段地址由选择的基址寄存器决定
    - 基址寄存器为BX，默认在数据段
    - 基址寄存器为BP，默认在堆栈段
- 基址变址寻址方式与相对寻址方式一样，主要用于一维数组操作。

![avatar](/img/in-post/2019-12-23-weiji1/5.PNG)

6. 隐含寻址:指令中隐含了一个或两个操作数的地址，即操作数在默认的地址中。

> MUL  BL

指令执行:AL×BL->AX


### 8086指令级

从功能上说：数据传送，算术运算，逻辑运算和移位，串操作，程序控制，处理器控制

#### 数据传送指令

##### 通用数据传送

1. 一般数据传送指令 MOV
   
- 注意点：
    - 两操作数字长必须相同；
    - 两操作数不允许同时为存储器操作数；
    - 两操作数不允许同时为段寄存器；
    - 在源操作数是立即数时，目标操作数不能是段寄存器；
    - IP和CS不作为目标操作数，FLAGS一般也不作为操作数在指令中出现。

2. 堆栈操作指令 PUSH POP

    PUSH：

    - 指令执行过程：
    - SP - 2 → SP
    - 操作数高字节 → SP+1
    - 操作数低字节 → SP

    sp：栈顶指针
    ![avatar](/img/in-post/2019-12-23-weiji1/6.PNG)

    入栈时，先存放高字节，低字节放之后。POP同理

    注意：

    - 指令的操作数必须是16位的；
    - 操作数可以是寄存器或存储器两单元，但不能是立即数；
    - 不能从栈顶弹出一个字给CS；
    - PUSH和POP指令在程序中一般成对出现；
    - PUSH指令的操作方向是从高地址向低地址，而POP指令的操作正好相反。

3. 交换指令
   
    XCHG  REG，MEM/REG

    两操作数必须有一个是寄存器操作数，不允许使用段寄存器。

4. 查表指令

    XLAT
   
   可用如下指令实现：
    ```
    MOV  BX，2000H      ；BX←表首地址
    MOV  AL，0BH        ；AL←序号
    XLAT                ；查表转换
    ```
    执行后：AL = 42H

5. 字位扩展指令

    1. 字节到字的扩展指令 CBW 
        - 操作：将AL内容扩展到AX
        - 规则：若最高位=1，则执行后AH=FFH,若最高位=0，则执行后AH=00H
    2. 字到双字的扩展指令 CWD
        - 操作：将AX内容扩展到DX  AX
        - 规则：若最高位=1，则执行后DX=FFFFH,若最高位=0，则执行后DX=0000H

#### 输入输出指令

- 指令的格式及操作
- 指令的两种寻址方式
- 指令对操作数的要求

1. 专门面向I/O端口操作的指令：

   - I/O接口种用于存储数据、可以直接被CPU访问的寄存器。
   - 计算机输入输出系统中可以包含若干接口控制电路，每个接口都包含了一个或多个端口



   **端口与接口**：
   ![avatar](/img/in-post/2019-12-23-weiji1/7.PNG)

2. 专门面向I/O端口操作的指令

    输入指令： `IN  acc，PORT`  
    输出指令 ：`OUT  PORT，acc`

    - 直接寻址
    端口地址为8位时，指令中直接给出8位端口地址；寻址256个端口。
    - 间接寻址
    端口地址为16位时，指令中的端口地址必须由DX指定；可寻址64K个端口。

    ```
    IN  AX，80H
    MOV DX，2400H
    IN  AL，DX
    OUT  35H ，AX
    OUT  AX，35H

    ```

#### 地址传送指令

。。。

### 算数运算类指令

1. 加法指令
   1. ADD指令 ADD  OPRD1，OPRD2
   
         ADD指令的执行对全部6个状态标志位都产生影响
    2. ADC指令 
   
         OPRD1+OPRD2+CF  OPRD1需要预先将CF清零
    3. INC指令

2. 减法指令
   1. SUB指令 同ADD
   2. SBB指令 同ADC   

        OPRD1- OPRD2- CF OPRD1
   3. DEC指令 同INC
   4. NEG指令 
   
        0 - OPRD  OPRD相当于求补码
    5. CMP指令
   
        指令执行的结果不影响目标操作数，仅影响标志位！

3. 乘法指令
   - 无符号的乘法指令MUL
   - *带符号的乘法指令IMUL

    MUL  OPRD： OPRD 不能是立即数
4. 除法指令
   - 无符号除法指令 DIV OPRD
   - 有符号除法指令 IDIV OPRD
   - 若OPRD是字节数
  
        执行：AX/OPRD          
        结果：AL=商  AH=余数

   - 若OPRD是双字节数
  
        执行： DXAX/OPRD    
        结果：AX=商 DX=余数

### 逻辑运算和位移指令

#### 逻辑运算

“非”运算指令 要求操作数 不能是立即数；

除“非”运算指令 外，其余指令的执行都会使标志位OF=CF=0 （AF不会影响）

1. 与运算 ADD
   - 实现两操作数  按位相与的  运算
    `AND  BL，[SI]`
   - 使目标操作数的  某些位不变，某些位清零
    `AND  AL，0FH`
   - 在操作数  不变的  情况下使CF和OF清零
    `AND  AX，AX`

2. 或指令 OR
     -  实现两操作数  相 “或”的  运算
   `OR  AX，[DI]`
      - 使某些位不变，某些位置“1”
   `OR  CL，0FH`
      - 在不改变操作数的  情况下使OF=CF=0
   `OR  AX，AX`

3. 非指令 NOT

   - 指令中的操作数不能是立即数
   - 指令的执行对标志位无影响

4. 异或指令 XOR
5. 测试指令 TEST

    执行“与”运算，但运算的结果不送回目标地址。

#### 位移指令
非循环指令
1. 算数左移指令 SAL
2. 逻辑左移指令 SHL
3. 逻辑右移指令 SHR
4. 算数右移指令 SAR

    - 逻辑左移=算数左移，右边统一添0 
    - 逻辑右移，左边统一添0 
    - 算数右移，左边添加的数和符号有关
  
非循环指令：左移实现乘法，右移实现除法

循环指令：

1. 不带进位的循环 ：左移 ROL，右移 ROR

2. 带进位的循环 ： 左移 RCL，右移  RCR


### 串操作指令

#### 说明

- 针对数据块或字符串的操作；
- 可实现存储器到存储器的数据传送；
- 待操作的数据串称为源串，目标地址称为目标串。
- 串操作指令的操作对象是多个字节数（一串字符或数据），因此，指令的执行需要确定；
    - 串所在的区域；
    - 串的首地址(原串、目标串起始地址）
    - 串长度（大小）
    - 串的操作方向

#### 特点

- 串所在区域及首地址
- 源串一般存放在数据段，偏移地址由SI指定。允许段重设；
目标串必须在附加段，偏移地址由DI指定；
- 串指令方向：指令自动修改地址指针，修改方向由DF决定。DF=0，DF=1
- 串长度：数据块长度值由CX指定

- 重复前缀

  - 无条件重复
  REP
  当CX≠0时，REP后得指令将继续重复执行
  常用于传送类指令前            未传完则继续传送
  - 条件重复
      - 相等（为零）重复：REPE(REPZ)。
      CX≠0 ∩ ZF=1, 则前缀后得指令将继续重复执行
      - 不相等（不为零）重复：REPNE(REPNZ）
      CX≠0 ∩ ZF=0, 则前缀后得指令将继续重复执行

#### 传操作指令

1. 串传输指令 MOVS OPRD1，OPRD2(MOVSB,MOVSW)
   > 串传送指令常与无条件重复前缀连用


    ![avatar](/img/in-post/2019-12-23-weiji1/8.PNG)


 2. 串比较指令CMPS OPRD1，OPRD2(CMPSB,CMPSW)
  `
     > 指令的执行不改变操作数，仅影响标志位。
    ```
    测试200个字节是否在正确传输

    LEA  SI，MEM1
    LEA  DI，MEM2
    MOV  CX，200
    CLD 
    REPE   CMPSB 
    TEST  CX，00FFH
    ```

 3. 传扫描指令 SCANS OPRD (SCANSB,SCANSW)
    > 这里的源操作数是AX或AL

    > 常用于在指定存储区域中寻找某个关键字。

 4. 串装入指令 LODS OPRD    
    操作：      
    对字节：AL<-[DS:SI]
    对字：AX<-[DS:SI]

    >用于将内存某个区域的数据串依次装入累加器，以便显示或输出到接口。
    >LODS指令一般不加重复前缀。

 5. 串存储指令 STOPS OPRD (STOPSB,STOPW)

    - 常用于将内存某个区域置同样的值

        - 将待送存的数据放入AL（字节数）或AX（字数据）；
        - 确定操作方向（增地址/减地址）和区域大小（串长度值）；
        - 使用串存储指令+无条件重复前缀，实现数据传送。





### 程序控制指令

#### 转移指令
通过修改指令的**偏移地址**或**段地址**及**偏移地址**实现程序的转移

1. 无条件跳转指令
   - 段内直接转移  Jump lable  段内：目标地址16位
   - 段内间接转移 Jump bx
   - 段间直接转移 Jump Far lable
   - 段间间接转移 JMP  DWORD  PTR[BX]
2. 条件转移指令
   1. 基于1个标志位状态实现转移的指令
       - JC/JNC
       判断CF的状态。常用于比大小
       - JZ/JNZ
       判断ZF的状态。常用于循环体的结束判断
       - JO/JNO
       判断OF的状态。常用于有符号数溢出的判断
       - JP/JPE
       判断PF的状态。用于判断运算结果低8位中1的个数是否为偶数
       - JS/JNS
       判断SF的状态。常用于判断数的性质
    2. 基于2个或3个标志位状态实现转移的指令
        - JA/JAE/JB/JNE
        - 判断CF或CF+ZF的状态。常用于无符号数大小的比较
        - JG/JGE/JL/JLE
        - 判断SF+OF或SF+OF+ZF的状态。常用于有符号数大小的比较
    3. 基于CX内容实现转移的指令
        - JCXZ
        可根据指令执行后CX的结果实现转移

































 








